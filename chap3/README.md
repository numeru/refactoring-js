# chap3. 리팩토링을 해야 하는 시점

1. 기이한 이름

- 이름만 보고 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야한다.

2. 중복 코드

- 똑같은 코드구조가 반복된다면 하나로 통합한다.

3. 긴 함수

- 함수 본문에서 따로 빼내어 새로운 함수로 만든다.

4. 긴 매개변수 목록

- 다른 매개변수에서 값을 가져오거나, 객체로 묶어서 전달한다.

5. 전역 데이터

- 함수로 감싸서 사용하는 등, 최대한 사용하지 않는다.

6. 가변 데이터

- 특정 상황에서만 수정이 가능하도록 하거나, 유효범위를 제한한다.

7. 뒤엉킨 변경

- 각각의 모듈로 구분하여 유연하게 대응이 가능하도록 한다.

8. 산탄총 수술

- 비슷한 데이터는 한 모듈에 묶어 관리되도록 한다.

9. 기능 편애

- 다른 모듈과 상호작용이 잦을 경우 적절히 이동시켜준다.

10. 데이터 뭉치

- 함께 사용되는 데이터는 한 곳에 모아둔다.

11. 기본형 집착

- 기본형이 아닌 특정 문제에 맞는 기초 타입을 재정의 한다.

12. 반복되는 switch문

- 다형성을 위해 switch문을 지양한다.

13. 반복문

- 필터나 맵같은 파이프라인 연산을 사용한다.

14. 성의 없는 요소

- 적은 요소들을 특별한 의미없이 묶은 것들은 풀거나 합친다.

15. 추측성 일반화

- 당장 필요 없는데 미리 만들어둔 코드들은 판단 후 제거한다.

16. 임시 필드

- 특정 상황에서만 값이 설정되는 필드는 사용자가 존재 이유를 파악하기 어려우므로, 적절한 곳으로 이동시킨다.

17. 메시지 체인

- 다른 객체를 요청하는 작업이 "."으로 연쇄적을 이어지는 경우 적절히 분리시켜준다.

18. 중개자

- 실제로 일을 하는 두 요소가 직접 소통하도록 만든다.

19. 내부자 거래

- 모듈 사이의 결합도가 높은 경우 적절히 이동시켜준다.

20. 거대한 클래스

- 한 클래스에서 너무 많은 일을 하지 않도록 한다.

21. 서로 다른 인터페이스의 대안 클래스들

- 한 클래스를 다른 클래스로 교체할 때 인터페이스에 맞추기 위해 메서드를 추가하는데, 중복코드가 발생하면 이를 묶는 슈퍼코드를 적용한다.

22. 데이터 클래스

- 데이터와 게터, 세터 메서드로만 이루어진 클래스는 캡슐화하거나 다른 클래스로 이동시킨다.

23. 상속 포기

- 자식 클래스가 부모클래스의 메서드와 데이터를 전부 물려받기를 원치 않는 경우, 중간에 서브클래스를 두거나 위임으로 변경한다.

24. 주석

- 가장 먼저 장황한 주석이 필요없는 코드로 리팩토링해본다.
